/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Mon Aug 01 2022 19:13:23 GMT-0400 (Eastern Daylight Time).
 */

define(["jointjs", "css!./styles/SimVizWidget.css"], function (joint) {
  "use strict";

  var WIDGET_CLASS = "sim-viz";

  function SimVizWidget(logger, container) {
    this._logger = logger.fork("Widget");

    this._el = container;

    this.nodes = {};
    this._initialize();

    this._logger.debug("ctor finished");
  }

  SimVizWidget.prototype._initialize = function () {
    var width = this._el.width(),
      height = this._el.height(),
      self = this;

    // set widget class
    self._el.addClass(WIDGET_CLASS);

    // initialize Joint JS petrinet
    self._jointPetriNet = new joint.dia.Graph();
    self._jointPaper = new joint.dia.Paper({
      el: self._el,
      width: width,
      height: height,
      model: self._jointPetriNet,
      interactive: false,
    });
    // add event calls to elements
    self._jointPaper.on("element:pointerdblclick", function (elementView) {
      //FIXME: current should be current marking, representative of all places in PN.
      // const currentElement = elementView.model;
      // if (self._webgmePetriNet) {
      //   self._setCurrentState(self._webgmePetriNet.id2state[currentElement.id]);
      // }
      // set current marking maybe?
    });

    // Create a dummy header
    self._el.append("<h3>SimViz Events:</h3>");

    // Registering to events can be done with jQuery (as normal)
    self._el.on("dblclick", function (event) {
      event.stopPropagation();
      event.preventDefault();
      self.onBackgroundDblClick();
    });
  };

  SimVizWidget.prototype.onWidgetContainerResize = function (width, height) {
    this._logger.debug("Widget is resizing...");
  };

  // Adding/Removing/Updating items
  SimVizWidget.prototype.addNode = function (desc) {
    if (desc) {
      // Add node to a table of nodes
      var node = document.createElement("div"),
        label = "children";

      if (desc.childrenIds.length === 1) {
        label = "child";
      }

      this.nodes[desc.id] = desc;
      node.innerHTML =
        'Adding node "' +
        desc.name +
        '" (click to view). It has ' +
        desc.childrenIds.length +
        " " +
        label +
        ".";

      // TODO conditional class additions of each node here for transition and places

      this._el.append(node);
      node.onclick = this.onNodeClick.bind(this, desc.id);
    }
  };

  SimVizWidget.prototype.removeNode = function (gmeId) {
    var desc = this.nodes[gmeId];
    this._el.append('<div>Removing node "' + desc.name + '"</div>');
    delete this.nodes[gmeId];
  };

  SimVizWidget.prototype.updateNode = function (desc) {
    if (desc) {
      this._logger.debug("Updating node:", desc);
      this._el.append('<div>Updating node "' + desc.name + '"</div>');
    }
  };

  let PlaceCircle = function (place) {
    let children = [];
    for (var i = 0; i < place.currentMarking; i++) {
      children.push({
        tagName: "circle",
        selector: `place-${place.id}-token-${i}`,
        groupSelector: `place-${place.id}-tokens`,
      });
    }
    let circle = joint.dia.Element.define("custom.Circle", {
      position: place.position,
      attrs: {
        body: {
          width: "calc(w)",
          height: "calc(h)",
        },
      },
      markup: [
        {
          tagName: "circle",
          selector: "wrapper",
          attributes: {
            label: {
              text: place.name,
              fontWeight: "bold",
            },
            body: {
              strokeWidth: 3,
              cursor: "pointer",
            },
          },
          children: children,
        },
      ],
    });
    return new circle();
  };

  SimVizWidget.prototype.initializePlaceVertices = function (self) {
    /* create a Circle vertex for each place using Joint JS; create an object
    mapping the joint vertex ids back to the place ids and set
    petriNet.id2place as that object.
    also set each place.joint (petriNet.places[pid1,pid2,...].joint)
    to respective joint vertex
    */
    console.log("initializing place vertices");
    self._webgmePetriNet.id2place = {
      /* map on-screen ids to place ids */
    };
    Object.keys(self._webgmePetriNet.places).forEach((placeId) => {
      // let vertex = new joint.shapes.standard.Circle({
      //   position: self._webgmePetriNet.places[placeId].position,
      //   size: { width: 60, height: 60 },
      //   attrs: {
      //     label: {
      //       text: self._webgmePetriNet.places[placeId].name,
      //       fontWeight: "bold",
      //       /* FIXME: need child circles inside up to 12 to indicate marking! */
      //     },
      //     body: {
      //       strokeWidth: 3,
      //       cursor: "pointer",
      //     },
      //   },
      // });
      let vertex = PlaceCircle(self._webgmePetriNet.places[placeId]);
      console.log("vertex for place");
      console.log(vertex);
      vertex.addTo(self._jointPetriNet);
      self._webgmePetriNet.places[placeId].joint = vertex;
      self._webgmePetriNet.id2place[vertex.id] = placeId;
    });
  };

  SimVizWidget.prototype.initializeTransitionVertices = function (self) {
    /* create a white square vertex for each transition using Joint JS; create an object
    mapping the joint vertex ids back to the transition ids and set
    petriNet.id2transition as that object.
    also set each transition.joint (petriNet.transitions[tid1,tid2,...].joint)
    to respective joint vertex
    */
    console.log("initializing transition vertices");
    self._webgmePetriNet.id2transition = {
      /* map on-screen ids to place ids */
    };
    Object.keys(self._webgmePetriNet.transitions).forEach((transitionId) => {
      let vertex = new joint.shapes.standard.Rectangle({
        position: self._webgmePetriNet.transitions[transitionId].position,
        size: { width: 60, height: 60 },
        attrs: {
          label: {
            text: self._webgmePetriNet.transitions[transitionId].name,
            fontWeight: "bold",
          },
          body: {
            strokeWidth: 3,
            cursor: "pointer",
          },
        },
      });
      vertex.addTo(self._jointPetriNet);
      self._webgmePetriNet.transitions[transitionId].joint = vertex;
      self._webgmePetriNet.id2transition[vertex.id] = transitionId;
    });
  };

  SimVizWidget.prototype.initializeArcs = function (self, arcType) {
    console.log("initializing arcs");
    let arcsArray =
      arcType === "ArcPlaceToTransition"
        ? self._webgmePetriNet.arcsPlaceToTransition
        : self._webgmePetriNet.arcsTransitionToPlace;
    arcsArray.forEach((arc) => {
      let src =
        arcType === "ArcPlaceToTransition"
          ? self._webgmePetriNet.places[arc.src]
          : self._webgmePetriNet.transitions[arc.src];
      let dst =
        arcType === "ArcPlaceToTransition"
          ? self._webgmePetriNet.transitions[arc.dst]
          : self._webgmePetriNet.places[arc.dst];

      console.log("setting jointOutArcs for src:");
      console.log(src);
      src.jointOutArcs = src.jointOutArcs || {};
      let link = new joint.shapes.standard.Link({
        // need to use the joint ids from the actual place and trans ids
        source: { id: src.joint.id },
        target: { id: dst.joint.id },
        attrs: {
          line: {
            strokeWidth: 2,
          },
          wrapper: {
            cursor: "default",
          },
        },
        labels: [
          {
            position: {
              distance: 0.5,
              offset: 0,
              args: {
                keepGradient: true,
                ensureLegibility: true,
              },
            },
            attrs: {
              text: {
                text: arc.name,
                fontWeight: "bold",
              },
            },
          },
        ],
      });
      link.addTo(self._jointPetriNet);
      src.jointOutArcs[arc.id] = link;
    });
  };

  // State Machine manipulating functions called from the controller
  SimVizWidget.prototype.initMachine = function (petriNetDescriptor) {
    console.log("petriNetDescriptor");
    console.log(petriNetDescriptor);
    const self = this;
    self._webgmePetriNet = petriNetDescriptor;
    self._jointPetriNet.clear();
    SimVizWidget.prototype.initializePlaceVertices(self);
    SimVizWidget.prototype.initializeTransitionVertices(self);
    ["ArcPlaceToTransition", "ArcTransitionToPlace"].forEach((arcType) => {
      SimVizWidget.prototype.initializeArcs(self, arcType);
    });
    console.log("refreshing visualization");
    //now refresh the visualization
    self._jointPaper.updateViews();
    console.log("refreshed with .updateViews()");

    console.log("decorating machine with ._decorateMachine()");
    self._decorateMachine();
    console.log("decorated");
  };

  SimVizWidget.prototype.destroyMachine = function () {};

  SimVizWidget.prototype.fireEvent = function (event) {
    // event an arc to fire.

    /* The following definitions cover how the petri net
    progress from one marking to another:
    1) t∈T is ​enabled ​if∀p∈P |∃f(p→t)∈F M(p) > 0 - for all
    ​inplaces ​of the transition (that are connected to the
      transition via an incoming arc) the amount of tokens
      at the place is non zero

    2) Firing ​an enabled transition decreases the amount of
    tokens on all ​inplaces w​ ith one and increases the amount
    of token in all ​outplaces ​of the transition by one.
    */
    console.log("fire event");
    console.log(event);

    const self = this;
    if (this._webgmePetriNet.deadlockActive(self._webgmePetriNet)) {
      this._client.sendMessageToPlugin(
        "PetriNetClassifier",
        "DEADLOCK_MSG",
        "Deadlock has been reached"
      );
    } else {
      // get the place from which this arc is coming.
      let srcId = event.src;
      console.log(`event src id = ${srcId}`);
      let src = this._webgmePetriNet.places[srcId];
      console.log("actual src");
      console.log(src);
      let link = src.jointOutArcs[event.id];
      console.log("link: ");
      console.log(link);
      let linkView = link.findView(self._jointPaper);
      console.log("linkView");
      console.log(linkView);
      linkView.sendToken(
        joint.V("circle", { r: 10, fill: "black" }),
        { duration: 500 },
        function () {
          // self._webgmePetriNet.current = current.outArcs[event];
          self._decorateMachine();
        }
      );
    }
  };

  SimVizWidget.prototype.resetMachine = function () {
    this._webgmePetriNet.current = this._webgmePetriNet.startingPlace;
    //FIXME: current should be current marking, representative of all places in PN.
    this._decorateMachine();
  };

  SimVizWidget.prototype._decorateMachine = function () {
    const petriNet = this._webgmePetriNet;
    Object.keys(petriNet.places).forEach((placeId) => {
      petriNet.places[placeId].joint.attr("body/stroke", "#333333");
    });
    // need to decorate the active places using their currentMarking values
    Object.keys(petriNet.places).forEach((placeId) => {
      petriNet.places[placeId].joint.attr(
        "text/label",
        petriNet.places[placeId].currentMarking
      );
    });
    // fireable events SHOULD be an array of ArcsPlaceToTransition
    petriNet.setFireableEvents(
      petriNet.getFireableEvents(this._client, petriNet)
    );
  };

  SimVizWidget.prototype._setCurrentState = function (newCurrent) {
    //FIXME: current should be current marking, representative of all places in PN.
    this._webgmePetriNet.current = newCurrent;

    this._decorateMachine();
  };

  /* * * * * * * * Visualizer event handlers * * * * * * * */

  SimVizWidget.prototype.onNodeClick = function (/*id*/) {
    // This currently changes the active node to the given id and
    // this is overridden in the controller.
  };

  SimVizWidget.prototype.onBackgroundDblClick = function () {
    this._el.append("<div>Background was double-clicked!!</div>");
  };

  /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
  SimVizWidget.prototype.destroy = function () {};

  SimVizWidget.prototype.onActivate = function () {
    this._logger.debug("SimVizWidget has been activated");
  };

  SimVizWidget.prototype.onDeactivate = function () {
    this._logger.debug("SimVizWidget has been deactivated");
  };

  return SimVizWidget;
});
