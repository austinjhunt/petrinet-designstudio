/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Mon Aug 01 2022 19:13:23 GMT-0400 (Eastern Daylight Time).
 */

define(["css!./styles/SimVizWidget.css"], function () {
  "use strict";

  var WIDGET_CLASS = "sim-viz";

  function SimVizWidget(logger, container) {
    this._logger = logger.fork("Widget");

    this._el = container;

    this.nodes = {};
    this._initialize();

    this._logger.debug("ctor finished");
  }

  SimVizWidget.prototype._initialize = function () {
    var width = this._el.width(),
      height = this._el.height(),
      self = this;

    // set widget class
    this._el.addClass(WIDGET_CLASS);

    // Create a dummy header
    this._el.append("<h3>SimViz Events:</h3>");

    // Registering to events can be done with jQuery (as normal)
    this._el.on("dblclick", function (event) {
      event.stopPropagation();
      event.preventDefault();
      self.onBackgroundDblClick();
    });
  };

  SimVizWidget.prototype.onWidgetContainerResize = function (width, height) {
    this._logger.debug("Widget is resizing...");
  };

  // Adding/Removing/Updating items
  SimVizWidget.prototype.addNode = function (desc) {
    if (desc) {
      // Add node to a table of nodes
      var node = document.createElement("div"),
        label = "children";

      if (desc.childrenIds.length === 1) {
        label = "child";
      }

      this.nodes[desc.id] = desc;
      node.innerHTML =
        'Adding node "' +
        desc.name +
        '" (click to view). It has ' +
        desc.childrenIds.length +
        " " +
        label +
        ".";

      // TODO conditional class additions of each node here for transition and places

      this._el.append(node);
      node.onclick = this.onNodeClick.bind(this, desc.id);
    }
  };

  SimVizWidget.prototype.removeNode = function (gmeId) {
    var desc = this.nodes[gmeId];
    this._el.append('<div>Removing node "' + desc.name + '"</div>');
    delete this.nodes[gmeId];
  };

  SimVizWidget.prototype.updateNode = function (desc) {
    if (desc) {
      this._logger.debug("Updating node:", desc);
      this._el.append('<div>Updating node "' + desc.name + '"</div>');
    }
  };


  // State Machine manipulating functions called from the controller
  SimVizWidget.prototype.initMachine = function (machineDescriptor) {
    const self = this;
    console.log('machineDescriptor')
    console.log(machineDescriptor);

    self._webgmePetriNet = machineDescriptor;
    self._webgmePetriNet.current = self._webgmePetriNet.init;
    self._jointPetriNet.clear();
    const petriNet = self._webgmePetriNet;
    petriNet.id2state = {}; // this dictionary will connect the on-screen id to the state id
    // first add the states
    Object.keys(petriNet.states).forEach(stateId => {
        let vertex = null;
        if (petriNet.init === stateId) {
            vertex = new joint.shapes.standard.Circle({
                position: petriNet.states[stateId].position,
                size: { width: 20, height: 20 },
                attrs: {
                    body: {
                        fill: '#333333',
                        cursor: 'pointer'
                    }
                }
            });
        } else if (petriNet.states[stateId].isEnd) {
            vertex = new joint.shapes.standard.Circle({
                position: petriNet.states[stateId].position,
                size: { width: 30, height: 30 },
                attrs: {
                    body: {
                        fill: '#999999',
                        cursor: 'pointer'
                    }
                }
            });
        } else {
            vertex = new joint.shapes.standard.Circle({
                position: petriNet.states[stateId].position,
                size: { width: 60, height: 60 },
                attrs: {
                    label : {
                        text: petriNet.states[stateId].name,
                        //event: 'element:label:pointerdown',
                        fontWeight: 'bold',
                        //cursor: 'text',
                        //style: {
                        //    userSelect: 'text'
                        //}
                    },
                    body: {
                        strokeWidth: 3,
                        cursor: 'pointer'
                    }
                }
            });
        }
        vertex.addTo(self._jointPetriNet);
        petriNet.states[stateId].joint = vertex;
        petriNet.id2state[vertex.id] = stateId;
    });

    // then create the links
    Object.keys(petriNet.states).forEach(stateId => {
        const state = petriNet.states[stateId];
        Object.keys(state.next).forEach(event => {
            state.jointNext = state.jointNext || {};
            const link = new joint.shapes.standard.Link({
                source: {id: state.joint.id},
                target: {id: petriNet.states[state.next[event]].joint.id},
                attrs: {
                    line: {
                        strokeWidth: 2
                    },
                    wrapper: {
                        cursor: 'default'
                    }
                },
                labels: [{
                    position: {
                        distance: 0.5,
                        offset: 0,
                        args: {
                            keepGradient: true,
                            ensureLegibility: true
                        }
                    },
                    attrs: {
                        text: {
                            text: event,
                            fontWeight: 'bold'
                        }
                    }
                }]
            });
            link.addTo(self._jointPetriNet);
            state.jointNext[event] = link;
        })
    });

    //now refresh the visualization
    self._jointPaper.updateViews();
    self._decorateMachine();
};

SimVizWidget.prototype.destroyMachine = function () {

};

SimVizWidget.prototype.fireEvent = function (event) {
    const self = this;
    const current = self._webgmePetriNet.states[self._webgmePetriNet.current];
    const link = current.jointNext[event];
    const linkView = link.findView(self._jointPaper);
    linkView.sendToken(joint.V('circle', { r: 10, fill: 'black' }), {duration:500}, function() {
       self._webgmePetriNet.current = current.next[event];
       self._decorateMachine();
    });
};

SimVizWidget.prototype.resetMachine = function () {
    this._webgmePetriNet.current = this._webgmePetriNet.init;
    this._decorateMachine();
};

SimVizWidget.prototype._decorateMachine = function() {
    const petriNet = this._webgmePetriNet;
    Object.keys(petriNet.states).forEach(stateId => {
      petriNet.states[stateId].joint.attr('body/stroke', '#333333');
    });
    petriNet.states[petriNet.current].joint.attr('body/stroke', 'blue');
    petriNet.setFireableEvents(Object.keys(petriNet.states[petriNet.current].next));
};

SimVizWidget.prototype._setCurrentState = function(newCurrent) {
    this._webgmePetriNet.current = newCurrent;
    this._decorateMachine();
};


  /* * * * * * * * Visualizer event handlers * * * * * * * */

  SimVizWidget.prototype.onNodeClick = function (/*id*/) {
    // This currently changes the active node to the given id and
    // this is overridden in the controller.
  };

  SimVizWidget.prototype.onBackgroundDblClick = function () {
    this._el.append("<div>Background was double-clicked!!</div>");
  };

  /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
  SimVizWidget.prototype.destroy = function () {};

  SimVizWidget.prototype.onActivate = function () {
    this._logger.debug("SimVizWidget has been activated");
  };

  SimVizWidget.prototype.onDeactivate = function () {
    this._logger.debug("SimVizWidget has been deactivated");
  };

  return SimVizWidget;
});
